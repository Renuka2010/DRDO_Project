1ï¸âƒ£ How does your rule AST match with main program AST?

Important point:

ðŸ‘‰ You donâ€™t create a separate AST for the rule.
ðŸ‘‰ The rule is implemented as a pattern matcher.
ðŸ‘‰ The main program generates the AST.
ðŸ‘‰ Your rule searches inside that AST.

Flow:

User writes main.c

Clang builds AST for entire file

Your clang-tidy check runs

It visits specific AST nodes

If node matches rule condition â†’ report violation

RULE_CODE:-

void registerMatchers(MatchFinder *Finder) {
    Finder->addMatcher(gotoStmt().bind("goto"), this);
}

void check(const MatchFinder::MatchResult &Result) {
    const GotoStmt *GS = Result.Nodes.getNodeAs<GotoStmt>("goto");
    if (GS) {
        diag(GS->getBeginLoc(), "MISRA violation: avoid goto");
    }
}

2ï¸âƒ£ If we write code for each rule?

Yes ðŸ’¯

For each MISRA rule:

You write:

registerMatchers()

check()

You decide:

Which AST node type?

What condition?

When to report?


3ï¸âƒ£ How much percentage is required to say violation?

This is VERY important ðŸ‘‡

ðŸ‘‰ Static analysis is NOT percentage-based.
ðŸ‘‰ It is condition-based.

âŒ Wrong thinking:

â€œIf 70% matches â†’ violationâ€

âœ… Correct thinking:

â€œIf rule condition is satisfied â†’ violationâ€

Example:

Rule: â€œNo gotoâ€

If 1 goto exists â†’ violation

Even 1% is enough



CUSTOM CLANG_TIDY CHECK:-


for a custom clang-tidy check, you must write both:

.h â†’ declaration

.cpp â†’ implementation

Thatâ€™s the proper Clang architecture.

ðŸ§  Why Two Files?

Because clang-tidy follows standard C++ project structure.

ðŸ”¹ 1ï¸âƒ£ .h file (Header)

Contains:

Class declaration

Function declarations

Inheritance from ClangTidyCheck

Example:

class MisraGotoCheck : public ClangTidyCheck {
public:
  MisraGotoCheck(StringRef Name, ClangTidyContext *Context);

  void registerMatchers(MatchFinder *Finder) override;
  void check(const MatchFinder::MatchResult &Result) override;
};

This tells clang:

ðŸ‘‰ â€œA new rule exists.â€

ðŸ”¹ 2ï¸âƒ£ .cpp file (Implementation)

Contains:

registerMatchers() â†’ where AST pattern is written

check() â†’ where violation is reported

Example logic:

Finder->addMatcher(gotoStmt().bind("goto"), this);

This is where your rule AST is defined.

ðŸŽ¯ Real Structure Inside clang-tidy

Inside
Clang-Tidy
every check follows this pattern:

AvoidGotoCheck.h
AvoidGotoCheck.cpp

Even built-in checks like:

modernize-use-nullptr

readability-braces-around-statements

cppcoreguidelines-avoid-goto

All have .h + .cpp.

ðŸ”¥ So For Your MISRA Rule

You must create:

MisraGotoCheck.h
MisraGotoCheck.cpp

Then:

Add matcher in .cpp

Register in module

Build

Run

ðŸš¨ Important

If you write everything in one .cpp file, it might compile,
but it is not correct clang-tidy architecture.

Your sir will expect proper separation.

ðŸ§  Clean Architecture Flow
Header (.h)
    â†“
Implementation (.cpp)
    â†“
Register in Module
    â†“
Build
    â†“
Run check